import { CommonService } from './../../shared/common.service';
import { Component, Inject, OnInit, OnDestroy, ChangeDetectorRef } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialog } from '@angular/material/dialog';
import { HttpClient } from '@angular/common/http';
import { MatTableDataSource } from '@angular/material/table';
import { SelectionModel } from '@angular/cdk/collections';
import {
  catchError,
  debounceTime,
  distinctUntilChanged,
  firstValueFrom,
  map,
  Observable,
  of,
  Subject,
  switchMap,
  takeUntil,
} from 'rxjs';
import { SnackbarService } from 'src/app/shared/snackbar.service';

export interface AssignmentDialogData {
  storeNumber: string;
  storeName: string;
  taskNumber?: string;
  taskName?: string;
  iriWeek: string;
  territoryId: string;
  positionNumber?: string;
  positionName?: string;
  city?: string;
  address?: string;
  mode: 'StoreLevel' | 'TaskLevel' | 'ClusterLevel';
}

export interface NameOption {
  emp_name: string;
  emp_id: string;
  FirstName: string;
  LastName: string;
  value: string;
  id: string;
}

export interface DialogResult {
  hasChanges: boolean;
  data?: any;
  preservedFilters?: any; // Preserve filters used when dialog was opened
}

export interface ProximityFsr {
  empId: string;
  firstName: string;
  lastName: string;
  time: string;
  toll: number;
  totalCost: number;
  costRank: number;
  email: string;
  fsrPhoneNum: string;
  productivity?: number;
  assignmentStatus?: 'assigned' | 'unassigned'; // Optional status field
  rowSource?: 'proximity' | 'currentAssignment' | 'search'; // Track where the row came from
}

export interface TaskAssignmentRow {
  storeNumber: string;
  storeName: string;
  positionName: string;
  address: string;
  city: string;
  assignedTo: string;
  taskName: string;
  taskNumber?: string;
  isAllTask: boolean;
  tasks?: any; // Sub-grid task data
  empId?: string; //empId of assigned FSR (matches ProximityFsr.empId)
  empName?: string; //name of assigned FSR 
}

export interface FsrSearchRow {
  EmpId?: string;
  empid?: string;
  FirstName: string;
  LastName: string;
  AddrLine1: string;
  AssignedHrs: number;
  MaxHrs: number;
  PositionName: string;
  FsrPhoneNum?: string;
  phone?: string;
  FsrEmailID?: string;
  Email?: string;
}

@Component({
  selector: 'app-assignment-dialog',
  templateUrl: './assignment-dialog.component.html',
  styleUrls: ['./assignment-dialog.component.css'],
})
export class AssignmentDialogComponent implements OnInit, OnDestroy {
  // Form & Data Management
  filterForm: FormGroup;
  territories: any[] = [];
  private originMode:'StoreLevel'|'TaskLevel'|'ClusterLevel'='StoreLevel'
  // Three separate tables
  proximityDataSource = new MatTableDataSource<ProximityFsr>([]);
  fsrDataSource = new MatTableDataSource<any>([]);
  taskAssignmentDataSource = new MatTableDataSource<TaskAssignmentRow>([]);
  
  // Selection for task assignment table
  taskSelection = new SelectionModel<TaskAssignmentRow>(true, []);

  // UI State Management
  isLoading = false;
  showSpinner = false;
  isLoadingProximity = false;
  isLoadingTaskAssignment = false;
  private isSavingAssignment = false; // Guard flag to prevent concurrent API calls

  // Autocomplete
  filteredFirstNames: Observable<NameOption[]>;
  filteredLastNames: Observable<NameOption[]>;

  // Track Changes
  private hasChanges = false;
  private destroy$ = new Subject<void>();
  selectedFirstNameId: string = '';
  selectedLastNameId: string = '';
  private preservedFilters: any = null; // Store filters when dialog opens
  private loggeduser: string = ''; // Logged user ID for LanId parameter

  // Display Columns for  tables
  // proximityColumns: string[] = ['assign','unassign', 'empId','empName','productivity','cost', 'time', 'toll', 'phone', 'email'];
  proximityColumns: string[] = ['action', 'empId', 'empName', 'productivity', 'cost', 'time', 'toll', 'phone', 'email'];
  displayedColumns: string[] = [];
  taskAssignmentColumns: string[] = ['select', 'position', 'storeNumber', 'storeName','task','assignedTo','city','address'];

  // Task data cache
  private taskData: any[] = [];
  constructor(
    private dialogRef: MatDialogRef<AssignmentDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: AssignmentDialogData,
    private fb: FormBuilder,
    private http: HttpClient,
    private commonService: CommonService,
    private snackbar: SnackbarService,
    private dialog: MatDialog,
    @Inject('BASE_URL') private baseUrl: string,
    private cdr: ChangeDetectorRef
  ) {
    this.filterForm = this.fb.group({
      territory: [data.territoryId],
      firstName: [''],
      lastName: [''],
    });
  }

  async ngOnInit(): Promise<void> {
    // Get logged user ID
    this.loggeduser = localStorage.getItem("loggedUserId") || '';
    
    // Preserve current filters when dialog opens
    try {
      this.preservedFilters = await firstValueFrom(this.commonService.currentFilters$);
      
      // Ensure all required filter fields are present, especially territory_id
      if (this.preservedFilters) {
        // If territory_id is missing, use the one from dialog data
        if (!this.preservedFilters.territory_id && this.data.territoryId) {
          this.preservedFilters.territory_id = this.data.territoryId;
        }
        // If iri_week is missing, use the one from dialog data
        if (!this.preservedFilters.iri_week && this.data.iriWeek) {
          this.preservedFilters.iri_week = this.data.iriWeek;
        }
        // If country_id is missing, use the one from dialog data
        if (!this.preservedFilters.country_id) {
          this.preservedFilters.country_id = this.commonService.getCurrentCountry() || '1';
        }
      }
    } catch (error) {
      console.warn('Could not get current filters, will use data from dialog:', error);
      // Build filters from dialog data if currentFilters$ fails
      this.preservedFilters = {
        iri_week: this.data.iriWeek,
        territory_id: this.data.territoryId,
        country_id: this.commonService.getCurrentCountry() || '1',
      };
    }
    
    if(!this.data.iriWeek){
      const currentFilter = await firstValueFrom(this.commonService.currentFilters$);
      this.data.iriWeek = currentFilter.iri_week;
      if (!this.preservedFilters || Object.keys(this.preservedFilters).length === 0) {
        this.preservedFilters = currentFilter;
      } else {
        // Merge current filter with preserved filters to ensure all fields are present
        this.preservedFilters = {
          ...this.preservedFilters,
          iri_week: currentFilter.iri_week || this.preservedFilters.iri_week,
          territory_id: currentFilter.territory_id || this.preservedFilters.territory_id || this.data.territoryId,
          country_id: currentFilter.country_id || this.preservedFilters.country_id || this.commonService.getCurrentCountry() || '1',
        };
      }
    }
    this.originMode=this.data.mode
    await this.loadTerritories();
    this.setupAutocomplete();
    // Load proximity data FIRST so we can filter duplicates from GetCurrentAssignment
    await this.loadProximityData();
    // Then load current assignment - it will filter out FSRs already in proximity table
    await this.loadCurrentAssignment();
    await this.loadTaskAssignmentData();
    this.initializeDisplayedColumns();
    this.autoSelectBasedOnOrigin()
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  // ============================================================
  // DIALOG TITLE
  // ============================================================
  getDialogTitle(): string {
    const location =
      this.data.mode === 'ClusterLevel'
        ? `Cluster ${this.data.positionNumber}`
        : `Store ${this.data.storeName} (${this.data.storeNumber})`;

    const task = this.data.taskName ? `Task ${this.data.taskName}` : 'Task ALL';

    return `Assignment for ${location} - ${task}`;
  }

  // ============================================================
  // COLUMN MANAGEMENT
  // ============================================================
  private initializeDisplayedColumns(): void {
    this.displayedColumns = this.getDisplayedColumns();
  }

 private getDisplayedColumns(): string[] {
  const columns: string[] = [];

 
  columns.push('action'); 

  // Add info columns
  columns.push('name', 'address', 'assigned_hrs', 'max_hrs', 'cluster', 'contact');

  return columns;
}

  showColumn(columnName: string): boolean {
    return this.displayedColumns.includes(columnName);
  }

  // ============================================================
  // TABLE 1: LOAD PROXIMITY DATA
  // ============================================================
  private async loadProximityData(): Promise<void> {
    this.isLoadingProximity = true;
    try {
      const response = await firstValueFrom(
        this.http.post<any>(
          this.baseUrl + 'api/TaskAssinment/GetClosestFsr',
          {
            StoreNumber: this.data.storeNumber,
            CountryId: this.commonService.getCurrentCountry(),
            IriWeek: this.data.iriWeek,
          }
        )
      );

      if (response && response.length > 0) {
        // Check for non-sample C store
        if (response[0].nonSampleCStore !== 'NON SAMPLE C STORE') {
          const mappedData = response.map((item: any) => ({
            empId: item.EmpId || item.empId,
            firstName: item.FirstName || item.firstName,
            lastName: item.LastName || item.lastName,
            productivity: item.fsrProductivityPercentage,
            time: item.Time || item.time,
            toll: item.Toll || item.toll,
            totalCost: item.TotalCost || item.totalCost,
            costRank: item.CostRank || item.costRank,
            email: item.fsrEmailID || item.fsrEmailIDPersonal,
            fsrPhoneNum: item.fsrPhoneNum,
            rowSource: 'proximity' as const, // Mark as proximity row
          }));

          const sortedData = mappedData.sort(
            (a: ProximityFsr, b: ProximityFsr) =>
              (a.costRank || 0) - (b.costRank || 0)
          );

          // IMPORTANT: Only replace if this is the initial load (table is empty)
          // OR if we're refreshing after assignment (preserve fixed proximity rows structure)
          // If there are search results, they will be preserved and filtered in searchFsrs()
          // If there are current assignment rows, they will be preserved and updated in loadCurrentAssignment()
          this.proximityDataSource.data = sortedData;
        } else {
          // Non-sample C store - clear proximity data
          this.proximityDataSource.data = [];
        }
      } else {
        // No proximity data - clear table
        this.proximityDataSource.data = [];
      }
    } catch (error) {
      console.error('Error loading proximity data:', error);
      // On error, don't clear existing data - preserve what we have
    } finally {
      this.isLoadingProximity = false;
    }
  }

  // ============================================================
  //  LOAD TASK ASSIGNMENT DATA
  // ============================================================
  private async loadTaskAssignmentData(): Promise<void> {
    this.isLoadingTaskAssignment = true;
    try {
      await this.loadTaskDataIfNeeded();

      const rows: TaskAssignmentRow[] = [];

      // Add ALL row
      rows.push({
        storeNumber: this.data.storeNumber,
        storeName: this.data.storeName,
        positionName: this.data.positionName || this.data.positionNumber || '',
        address: this.data.address || '',
        city: this.data.city || '',
        assignedTo: 'ALL',
        taskName: 'ALL',
        isAllTask: true,
        tasks: this.taskData,
        empId: '', // ALL row has no empId
        empName: '',
      });

      // Add individual task rows with empId - UPDATED
      if (this.taskData && this.taskData.length > 0) {
        this.taskData.forEach((task: any) => {
          rows.push({
            storeNumber: task.storeNumber || this.data.storeNumber,
            storeName: task.storeName || this.data.storeName,
            positionName: task.positionName || this.data.positionName || this.data.positionNumber || '',
            address: task.addrLine1 || this.data.address || '',
            city: task.city || this.data.city || '',
            assignedTo: task.assignedTo || task.EmpName || 'Not Assigned',
            taskName: task.taskName,
            taskNumber: task.taskNumber,
            isAllTask: false,
            empId: task.empId || task.EmpId || '', // NEW - Store empId of assigned FSR
            empName: task.EmpName || task.empName || '', // NEW - Store name of assigned FSR
          });
        });
      }

      this.taskAssignmentDataSource.data = rows;
    } catch (error) {
      console.error('Error loading task assignment data:', error);
    } finally {
      this.isLoadingTaskAssignment = false;
    }
  }

  private async loadTaskDataIfNeeded(): Promise<void> {
    try {
      // For StoreLevel and TaskLevel, we need to fetch task data for the specific store
      if (
        this.data.mode === 'StoreLevel' ||
        this.data.mode === 'TaskLevel'
      ) {
        const params = {
          IriWeek: this.data.iriWeek,
          StoreNumber: this.data.storeNumber,
        };

        const response = await firstValueFrom(
          this.http.post<any>(
            this.baseUrl + 'api/TaskAssinment/GetSubgridData',
            params
          )
        );

        // Handle both response formats
        if (response && response.data && Array.isArray(response.data)) {
          this.taskData = response.data;
        } else if (Array.isArray(response)) {
          this.taskData = response;
        } else {
          this.taskData = [];
        }
      }
    } catch (error) {
      console.error('Error loading task data:', error);
      this.taskData = [];
    }
  }

  // ============================================================
  // CHECKBOX SELECTION LOGIC
  // ============================================================
  isAllSelected(): boolean {
    const numSelected = this.taskSelection.selected.length;
    const numRows = this.taskAssignmentDataSource.data.length;
    return numSelected === numRows;
  }

  masterToggle(): void {
    if (this.isAllSelected()) {
      this.taskSelection.clear();
    } else {
      this.taskAssignmentDataSource.data.forEach((row) =>
        this.taskSelection.select(row)
      );
    }
  }

  /**
   * Handle checkbox change event - prevents double-toggling
   */
  onCheckboxChange(event: any, row: TaskAssignmentRow): void {
    // MatCheckboxChange doesn't have stopPropagation, but change events don't bubble
    // The click event on checkbox already has stopPropagation, so this is safe
    
    // Toggle selection based on checked state
    if (event && event.checked !== undefined) {
      // Use the checked state from the event to avoid double-toggling
      if (event.checked && !this.taskSelection.isSelected(row)) {
        this.taskSelection.select(row);
      } else if (!event.checked && this.taskSelection.isSelected(row)) {
        this.taskSelection.deselect(row);
      }
    } else {
      // Fallback to toggle if checked state not available
      this.taskSelection.toggle(row);
    }
    
    this.onRowSelectionChange(row);
  }

  /**
   * Handle row click - prevents double-toggling when checkbox is clicked
   */
  onRowClick(event: MouseEvent, row: TaskAssignmentRow): void {
    // Don't toggle if click originated from checkbox (checkbox handles its own toggle)
    const target = event.target as HTMLElement;
    if (target.closest('mat-checkbox') || target.closest('.mat-checkbox')) {
      return; // Checkbox click is already handled, don't toggle again
    }
    
    // Only toggle if row is not disabled
    if (!this.isCheckboxDisabled(row)) {
      this.taskSelection.toggle(row);
      this.onRowSelectionChange(row);
    }
  }

  onRowSelectionChange(row: TaskAssignmentRow): void {
    // If user selects the ALL row, disable other rows
    if (row.isAllTask) {
      this.taskSelection.isSelected(row)
        ? // Clear all selections except ALL
          (this.taskSelection.clear(), this.taskSelection.select(row))
        : this.taskSelection.clear();
    } else if (!row.isAllTask) {
      this.taskSelection.isSelected(row)
        ? // If user selects a task-level row, deselect ALL row
          (() => {
            const allRow = this.taskAssignmentDataSource.data.find(
              (r) => r.isAllTask
            );
            if (allRow && this.taskSelection.isSelected(allRow)) {
              this.taskSelection.deselect(allRow);
            }
          })()
        : null;
    }
    
    // Trigger change detection to update assign/unassign buttons in FSR table
    // This ensures buttons update immediately when checkboxes are toggled
    this.cdr.detectChanges();
  }

  isRowDisabled(row: TaskAssignmentRow): boolean {
    // When ALL row is selected, don't disable rows for display purposes
    // All columns should display normally except checkbox
    return false;
  }

  /**
   * Check if checkbox should be disabled for a row
   * Checkbox is disabled for task-level rows when ALL row is selected
   */
  isCheckboxDisabled(row: TaskAssignmentRow): boolean {
    const allRow = this.taskAssignmentDataSource.data.find(
      (r) => r.isAllTask
    );
    if (allRow && this.taskSelection.isSelected(allRow)) {
      return !row.isAllTask; // Disable task-level rows when ALL is selected
    }
    return false;
  }

  // ============================================================
  // LOAD DATA METHODS
  // ============================================================
  private async loadTerritories(): Promise<void> {
    try {
      const currentCountry = this.commonService.getCurrentCountry() || '1';
      this.territories = await firstValueFrom(
        this.http.get<any>(this.baseUrl + `api/TaskAssinment/GetTerritory?countryId=${currentCountry}`)
      );
    } catch (error) {
      console.error('Error loading territories:', error);
    }
  }

  // ============================================================
  // HELPER: Filter out FSRs that are already in proximity table
  // ============================================================
  private filterOutProximityFsrs(fsrList: any[]): any[] {
    // Get all empIds from proximity table (GetClosestFsr returns empId)
    const proximityEmpIds = new Set<string>();
    this.proximityDataSource.data.forEach((proximityFsr: ProximityFsr) => {
      // GetClosestFsr API returns empId (lowercase) - stored in proximityFsr.empId
      const empId = proximityFsr.empId;
      if (empId) {
        // Normalize: trim and convert to string for consistent comparison
        proximityEmpIds.add(empId.toString().trim());
      }
    });

    // Filter out FSRs whose empId matches any proximity FSR
    // GetCurrentAssignment API returns EmpId (capital E)
    // GetFsrForAssignment API also returns EmpId (capital E)
    return fsrList.filter((fsr: any) => {
      // Check all possible field name variations: EmpId, empid, empId
      const fsrEmpId = (fsr.EmpId || fsr.empid || fsr.empId || '').toString().trim();
      
      // If empId is empty, don't filter it out
      if (!fsrEmpId) {
        return true;
      }
      
      // Check if this FSR's empId exists in proximity table
      return !proximityEmpIds.has(fsrEmpId);
    });
  }

  private async loadCurrentAssignment(): Promise<void> {
    this.isLoading = true;
    try {
      const params = {
        IriWeek: this.data.iriWeek,
        StoreNumber: this.data.storeNumber,
        TaskNumber: this.data.taskNumber || '',
        AssignmentMode: this.data.mode,
        PositionNumber: this.data.positionNumber || '',
        CountryId: this.commonService.getCurrentCountry(),
      };

      const response = await firstValueFrom(
        this.http.post<any>(
          this.baseUrl + 'api/TaskAssinment/GetCurrentAssignment',
          params
        )
      );

      // Properly map data
      let mappedData: any[] = [];
      if (response && response.length > 0) {
        mappedData = response.map((item: any) => ({
          ...item,
          EmpId: item.EmpId || item.empid || '',
          AssignedHrs: item.AssignedHrs || 0,
          MaxHrs: item.MaxHrs || 0,
          FirstName: item.FirstName || '',
          LastName: item.LastName || '',
        }));
      }

      // Filter out FSRs that are already in proximity table
      this.fsrDataSource.data = this.filterOutProximityFsrs(mappedData);
      
      // Identify fixed proximity rows (rows from loadProximityData - they have time, toll, totalCost, costRank)
      // These rows should remain constant regardless of count
      const fixedProximityRows = this.proximityDataSource.data.filter((fsr: ProximityFsr) => {
        // Proximity rows have time, toll, totalCost, or costRank (search/current assignment results have these as null)
        return fsr.time !== null || fsr.toll !== null || fsr.totalCost !== null || fsr.costRank !== null;
      });

      // Get empIds from fixed proximity rows to exclude them from current assignment
      const fixedProximityEmpIds = new Set<string>();
      fixedProximityRows.forEach((fsr: ProximityFsr) => {
        if (fsr.empId) {
          fixedProximityEmpIds.add(String(fsr.empId).trim());
        }
      });

      // Filter current assignment:
      // 1. Always exclude FSRs that are in fixed proximity rows (from GetClosestFsr)
      // 2. Include ALL current assignment FSRs that are NOT in fixed proximity rows
      //    (This includes search result FSRs that are now assigned - they will replace the search result rows)
      //    (This also includes new FSRs not in proximity table at all)
      const filteredCurrentAssignment = mappedData.filter((fsr: any) => {
        const fsrEmpId = String(fsr.EmpId || fsr.empid || fsr.empId || '').trim();
        if (!fsrEmpId) {
          return false; // Skip FSRs without empId
        }
        
        // Always exclude if in fixed proximity rows (from GetClosestFsr)
        // Include all others (search results will be replaced, new FSRs will be added)
        return !fixedProximityEmpIds.has(fsrEmpId);
      });

      // Map current assignment to ProximityFsr format
      const mappedCurrentAssignment: ProximityFsr[] = filteredCurrentAssignment.map((fsr: any) => ({
        empId: fsr.EmpId || fsr.empid || fsr.empId || null,
        firstName: fsr.FirstName || fsr.firstName || null,
        lastName: fsr.LastName || fsr.lastName || null,
        productivity: fsr.fsrProductivityPercentage || fsr.FsrProductivityPercentage || null,
        time: null, // Not available in current assignment
        toll: null, // Not available in current assignment
        totalCost: null, // Not available in current assignment
        costRank: null, // Not available in current assignment
        email: fsr.Email || fsr.FsrEmailID || fsr.email || null,
        fsrPhoneNum: fsr.Phone || fsr.FsrPhoneNum || fsr.fsrPhoneNum || null,
        assignmentStatus: this.isAlreadyAssignedProximity({ 
          empId: fsr.EmpId || fsr.empid || fsr.empId,
          firstName: null,
          lastName: null,
          time: null,
          toll: null,
          totalCost: null,
          costRank: null,
          email: null,
          fsrPhoneNum: null
        } as ProximityFsr) ? 'assigned' : 'unassigned',
        rowSource: 'currentAssignment' as const // Mark as current assignment row
      }));

      // Update proximity table: 
      // 1. Fixed proximity rows (from GetClosestFsr) - always keep these (they have proximity data)
      // 2. Current assignment rows - these replace ALL non-fixed rows (search results + previous assignments)
      // This ensures:
      // - Fixed proximity rows remain constant (never duplicated)
      // - Search result rows are completely replaced by current assignment data
      // - Newly assigned FSRs are added to the table
      // - No duplicates between fixed proximity, search results, and current assignment
      this.proximityDataSource.data = [...fixedProximityRows, ...mappedCurrentAssignment];
    } catch (error) {
      console.error('Error loading current assignment:', error);
      this.fsrDataSource.data = [];
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * Helper method to extract first name value from form control
   * Returns the typed string if user didn't select from dropdown,
   * or the FirstName property if user selected an option
   */
  private getFirstNameValue(value: any): string {
    if (!value) return '';
    // user typed but didn't select, return it directly
    if (typeof value === 'string') {
      return value.trim();
    }
    // If it's an object (user selected from dropdown), return FirstName property
    if (typeof value === 'object' && value.FirstName) {
      return value.FirstName;
    }
    return '';
  }

  /**
   * Helper method to extract last name value from form control
   * Returns the typed string if user didn't select from dropdown,
   * or the LastName property if user selected an option
   */
  private getLastNameValue(value: any): string {
    if (!value) return '';
    // user typed but didn't select, return it directly
    if (typeof value === 'string') {
      return value.trim();
    }
    // user selected from dropdown, return LastName property
    if (typeof value === 'object' && value.LastName) {
      return value.LastName;
    }
    // Fallback to FirstName if LastName doesn't exist (for backward compatibility)
    if (typeof value === 'object' && value.FirstName) {
      return value.FirstName;
    }
    return '';
  }

  async searchFsrs(): Promise<void> {
    // Validate that at least one name field is filled
    const formValue = this.filterForm.value;
    const firstNameValue = this.getFirstNameValue(formValue.firstName);
    const lastNameValue = this.getLastNameValue(formValue.lastName);

    if (!firstNameValue && !lastNameValue) {
      this.snackbar.openSnackBar('Please enter at least First Name or Last Name to search.', 'warning');
      return;
    }

    this.isLoading = true;
    try {
      const params = {
        IriWeek: this.data.iriWeek,
        TerritoryId: formValue.territory,
        FirstName: firstNameValue,
        LastName: lastNameValue,
        PositionNumber: this.data.positionNumber || '',
        countryId: this.commonService.getCurrentCountry(),
        Area: '23',
      };

      const response = await firstValueFrom(
        this.http.post<any[]>(
          this.baseUrl + 'api/TaskAssinment/GetFsrForAssignment',
          params
        )
      );

            
      // Identify fixed proximity rows (from GetClosestFsr - have time/toll/totalCost/costRank)
      const fixedProximityRows = this.proximityDataSource.data.filter((fsr: ProximityFsr) => {
        return fsr.time !== null || fsr.toll !== null || fsr.totalCost !== null || fsr.costRank !== null;
      });

      // Identify current assignment rows (from GetCurrentAssignment - have rowSource === 'currentAssignment')
      // These are FSRs that are actually assigned to tasks, not just search results
      const currentAssignmentRows = this.proximityDataSource.data.filter((fsr: ProximityFsr) => {
        // Current assignment rows are explicitly marked with rowSource === 'currentAssignment'
        return fsr.rowSource === 'currentAssignment';
      });

      // Get empIds from fixed proximity rows to filter duplicates
      const fixedProximityEmpIds = new Set<string>();
      fixedProximityRows.forEach((fsr: ProximityFsr) => {
        if (fsr.empId) {
          fixedProximityEmpIds.add(String(fsr.empId).trim());
        }
      });

      // Get empIds from current assignment rows to filter duplicates
      // Only filter out FSRs that are actually assigned (from GetCurrentAssignment), not search results
      const currentAssignmentEmpIds = new Set<string>();
      currentAssignmentRows.forEach((fsr: ProximityFsr) => {
        if (fsr.empId) {
          currentAssignmentEmpIds.add(String(fsr.empId).trim());
        }
      });

      // Filter out FSRs that are already in:
      // 1. Fixed proximity rows (from GetClosestFsr) - always exclude these
      // 2. Current assignment rows (from GetCurrentAssignment) - exclude assigned FSRs
      // NOTE: We do NOT filter out previous search results - they will be replaced by new search results
      const filteredResults = (response || []).filter((fsr: any) => {
        const fsrEmpId = String(fsr.EmpId || fsr.empid || fsr.empId || '').trim();
        // Exclude if in fixed proximity OR current assignment (assigned FSRs)
        // But allow search results to be re-added even if they were in previous search
        return !fixedProximityEmpIds.has(fsrEmpId) && !currentAssignmentEmpIds.has(fsrEmpId);
      });
      
      // Map search results to ProximityFsr format
      const mappedSearchResults: ProximityFsr[] = filteredResults.map((fsr: any) => ({
        empId: fsr.EmpId || fsr.empid || fsr.empId || null,
        firstName: fsr.FirstName || fsr.firstName || null,
        lastName: fsr.LastName || fsr.lastName || null,
        productivity: fsr.FsrProductivityPercentage || null,
        time: null, // Not available in search results
        toll: null, // Not available in search results
        totalCost: null, // Not available in search results
        costRank: null, // Not available in search results
        email: fsr.Email || fsr.FsrEmailID || fsr.email || null,
        fsrPhoneNum: fsr.Phone || fsr.FsrPhoneNum || fsr.fsrPhoneNum || null,
        assignmentStatus: this.isAlreadyAssignedProximity({ 
          empId: fsr.EmpId || fsr.empid || fsr.empId,
          firstName: null,
          lastName: null,
          time: null,
          toll: null,
          totalCost: null,
          costRank: null,
          email: null,
          fsrPhoneNum: null
        } as ProximityFsr) ? 'assigned' : 'unassigned',
        rowSource: 'search' as const // Mark as search result row
      }));

      // Keep fixed proximity rows and current assignment rows, then add new search results
      // This ensures:
      // - Fixed proximity rows remain constant
      // - Current assignment rows (assigned FSRs) remain constant
      // - Previous search results are replaced with new search results
      // - No duplicates between fixed proximity, current assignment, and search results
      this.proximityDataSource.data = [...fixedProximityRows, ...currentAssignmentRows, ...mappedSearchResults];
    } catch (error) {
      console.error('Error searching FSRs:', error);
      this.snackbar.openSnackBar('Error searching for FSRs. Please try again.', 'error');
    } finally {
      this.isLoading = false;
    }
  }

  // ============================================================
  // HELPER: Save and Restore Selections
  // ============================================================
  private saveTaskSelections(): Array<{ storeNumber: string; taskNumber?: string; isAllTask: boolean }> {
    return this.taskSelection.selected.map(row => ({
      storeNumber: row.storeNumber,
      taskNumber: row.taskNumber,
      isAllTask: row.isAllTask
    }));
  }

  private restoreTaskSelections(savedSelections: Array<{ storeNumber: string; taskNumber?: string; isAllTask: boolean }>): void {
    if (!savedSelections || savedSelections.length === 0) {
      return;
    }

    // Find matching rows in the new data and restore selections
    savedSelections.forEach(saved => {
      const matchingRow = this.taskAssignmentDataSource.data.find(row => {
        if (saved.isAllTask) {
          return row.isAllTask;
        } else {
          return row.storeNumber === saved.storeNumber && 
                 row.taskNumber === saved.taskNumber && 
                 !row.isAllTask;
        }
      });

      if (matchingRow) {
        this.taskSelection.select(matchingRow);
      }
    });
  }

  // ============================================================
  // TABLE 1: ASSIGN/UNASSIGN METHODS
  // ============================================================

  /**
   * Assign FSR from Proximity Table (Table 1)
   */
  async assignFromProximity(fsr: ProximityFsr): Promise<void> {
    // Prevent concurrent calls
    if (this.isSavingAssignment) {
      return;
    }
    await this.assignTaskWithSelection(fsr, 'proximity');
  }

  /**
   * Unassign FSR from Proximity Table (Table 1)
   */
  async unassignFromProximity(fsr: ProximityFsr): Promise<void> {
    // Prevent concurrent calls
    if (this.isSavingAssignment) {
      return;
    }
    
    const selectedRows = this.taskSelection.selected;
    if (selectedRows.length === 0) {
      this.snackbar.openSnackBar('Please select at least one task to unassign.', 'warning');
      return;
    }

    const fsrName = `${fsr.firstName} ${fsr.lastName}`;
    const empId = fsr.empId;

    const allSelected = selectedRows.some((row) => row.isAllTask);

    let confirmMessage: string;
    if (allSelected) {
      confirmMessage = `Are you sure you want to unassign ${fsrName} from all tasks?`;
    } else {
      const taskNames = selectedRows.map((row) => row.taskName).join(', ');
      confirmMessage = `Are you sure you want to unassign ${fsrName} from ${taskNames}?`;
    }

    // if (!confirm(confirmMessage)) {
    //   return;
    // }

    this.showSpinner = true;
    try {
      if (allSelected) {
        const params = {
          IriWeek: this.data.iriWeek,
          TerritoryId: this.filterForm.get('territory')?.value,
          StoreNumber: this.data.storeNumber,
          EmpId: empId,
          TaskNumber: '',
          PositionNumber: this.data.positionNumber||null,
          Action: '4', // Unassign all
          AssignmentMode: 'StoreLevel',
          CountryId: this.commonService.getCurrentCountry(),
          LanId: this.loggeduser,
        };
        await firstValueFrom(
          this.http.post(
            this.baseUrl + 'api/TaskAssinment/SaveAssignment',
            params
          )
        );
      } else {
        for (const row of selectedRows) {
          const params = {
            IriWeek: this.data.iriWeek,
            TerritoryId: this.filterForm.get('territory')?.value,
            StoreNumber: row.storeNumber,
            EmpId: empId,
            TaskNumber: row.taskNumber,
            PositionNumber: this.data.positionNumber,
            Action: '3', // Unassign specific task
            AssignmentMode: 'TaskLevel',
            CountryId: this.commonService.getCurrentCountry(),
            LanId: this.loggeduser,
          };
          await firstValueFrom(
            this.http.post(
              this.baseUrl + 'api/TaskAssinment/SaveAssignment',
              params
            )
          );
        }
      }

      // Save selections before reloading data
      const savedSelections = this.saveTaskSelections();

      this.hasChanges = true;
      await this.loadTaskAssignmentData();
      await this.loadProximityData();
      await this.loadCurrentAssignment(); // This will add current assignment rows to proximity table
      
      // Restore selections after reloading data
      this.restoreTaskSelections(savedSelections);
      
      this.filterForm.patchValue({ firstName: '', lastName: '' });
      this.snackbar.openSnackBar('Unassignment completed successfully.', 'success');
    } catch (error) {
      console.error('Error during unassignment:', error);
      this.snackbar.openSnackBar('Error while unassigning. Please try again.', 'error');
    } finally {
      this.showSpinner = false;
      this.isSavingAssignment = false; // Reset guard flag
    }
  }

  // ============================================================
  // TABLE 2: ASSIGN/UNASSIGN METHODS - UPDATED WITH empId LOGIC
  // ============================================================

  /**
   * Check if an FSR (from Proximity table) is already assigned
   * by looking in taskAssignmentDataSource for matching empId
   * KEY FIX: Uses task empId instead of AssignedHrs
   */
  isAlreadyAssigned(fsr: ProximityFsr): boolean {
    // Return false if task data not loaded yet
    if (
      !this.taskAssignmentDataSource.data ||
      this.taskAssignmentDataSource.data.length === 0
    ) {
      return false;
    }

    // Search through task rows for matching empId
    const isAssigned = this.taskAssignmentDataSource.data.some((task) => {
      // Skip rows without assignment
      if (
        task.assignedTo &&
        task.assignedTo !== 'Not Assigned' &&
        task.assignedTo !== 'ALL'
      ) {
        // Method 1: Direct empId match
        if (task.empId === fsr.empId) {
          return true;
        }
        // Method 2: Check if assignedTo contains FSR's empId
        if (task.assignedTo.includes(fsr.empId)) {
          return true;
        }
      }
      return false;
    });

    return isAssigned;
  }

  /**
   * Check if an FSR (from FSR Search table) is already assigned
   * by looking in taskAssignmentDataSource for matching empId
   * KEY FIX: Uses task empId instead of AssignedHrs
   */
  isAlreadyAssignedFsr(fsr: any): boolean {
    // Return false if task data not loaded yet
    if (
      !this.taskAssignmentDataSource.data ||
      this.taskAssignmentDataSource.data.length === 0
    ) {
      return false;
    }

    // Get FSR's ID (handle different field name variations)
    const fsrId = fsr.EmpId || fsr.empid || fsr.empId;

    // Search through task rows for matching empId
    const isAssigned = this.taskAssignmentDataSource.data.some((task) => {
      // Skip the "ALL" row
      if (task.isAllTask) {
        return false;
      }

      // Skip rows without assignment
      if (task.assignedTo && task.assignedTo !== 'Not Assigned') {
        // Method 1: Direct empId match
        if (task.empId === fsrId) {
          return true;
        }
        // Method 2: Check if assignedTo contains FSR's ID
        if (task.assignedTo.includes(fsrId)) {
          return true;
        }
        // Method 3: Check if assignedTo contains FSR's full name
        const fsrFullName = `${fsr.FirstName} ${fsr.LastName}`;
        if (task.assignedTo.includes(fsrFullName)) {
          return true;
        }
      }

      return false;
    });

    return isAssigned;
  }

  /**
   * Determine if a button should be disabled based on task assignment status
   * Uses empId matching against task rows
   */
  shouldDisableButton(fsr: any, actionType: string): boolean {
    const alreadyAssigned = this.isAlreadyAssignedFsr(fsr);

    // Disable Assign buttons if already assigned
    if (['assign_all', 'assign', 'assigntocluster'].includes(actionType)) {
      return alreadyAssigned;
    }

    // Disable Unassign buttons if NOT assigned
    if (
      ['unassign_all', 'unassign', 'unassignfromcluster'].includes(actionType)
    ) {
      return !alreadyAssigned;
    }

    return false;
  }

  /**
   * Assign task method 
   */

  async assignTask(fsr: any, action: number): Promise<void> {
  // Prevent concurrent calls
  if (this.isSavingAssignment) {
    return;
  }
  
  const selectedRows = this.taskSelection.selected;
  
  // Check if at least one task is selected
  if (selectedRows.length === 0) {
    this.snackbar.openSnackBar('Please select at least one task to perform this action.', 'warning');
    return;
  }

  const fsrName = `${fsr.FirstName} ${fsr.LastName}`;
  const fsrId = fsr.EmpId || fsr.empid || fsr.empId;
  
  // Determine if ALL row is selected
  const allRowSelected = selectedRows.some((row) => row.isAllTask);
  
  // Build confirmation message based on action
  let confirmMessage = '';
  let targetDescription = '';
  
  if (action === 2) {
    // Assign all
    confirmMessage = `Are you sure you want to assign ${fsrName} to ALL tasks?`;
    targetDescription = 'all tasks';
  } else if (action === 4) {
    // Unassign all
    confirmMessage = `Are you sure you want to unassign ${fsrName} from ALL tasks?`;
    targetDescription = 'all tasks';
  } else if (action === 1) {
    // Assign specific task(s)
    const specificTasks = selectedRows.filter((row) => !row.isAllTask);
    const taskNames = specificTasks.map((row) => row.taskName).join(', ');
    confirmMessage = `Are you sure you want to assign ${fsrName} to ${taskNames}?`;
    targetDescription = taskNames;
  } else if (action === 3) {
    // Unassign specific task(s)
    const specificTasks = selectedRows.filter((row) => !row.isAllTask);
    const taskNames = specificTasks.map((row) => row.taskName).join(', ');
    confirmMessage = `Are you sure you want to unassign ${fsrName} from ${taskNames}?`;
    targetDescription = taskNames;
  }

  // if (!confirm(confirmMessage)) {
  //   return;
  // }

  // Set guard flag to prevent concurrent calls
  this.isSavingAssignment = true;
  this.showSpinner = true;
  try {
    if (action === 2 || action === 4) {
      // Assign All or Unassign All
      const params = {
        IriWeek: this.data.iriWeek,
        TerritoryId: this.filterForm.get('territory')?.value,
        StoreNumber: this.data.storeNumber,
        EmpId: fsrId,
        TaskNumber: '', // Empty for ALL
        PositionName: this.data.positionNumber,
        Action: String(action), // 2 or 4
        AssignmentMode: 'StoreLevel',
        CountryId: this.commonService.getCurrentCountry(),
        LanId: this.loggeduser,
      };

      await firstValueFrom(
        this.http.post(
          this.baseUrl + 'api/TaskAssinment/SaveAssignment',
          params
        )
      );
    } else if (action === 1 || action === 3) {
      // Assign or Unassign specific task(s)
      // Only process non-ALL rows
      const specificTasks = selectedRows.filter((row) => !row.isAllTask);
      
      if (specificTasks.length === 0) {
        this.snackbar.openSnackBar('No specific tasks selected.', 'warning');
        return;
      }

      // Process each specific task
      for (const row of specificTasks) {
        const params = {
          IriWeek: this.data.iriWeek,
          TerritoryId: this.filterForm.get('territory')?.value,
          StoreNumber: row.storeNumber,
          EmpId: fsrId,
          TaskNumber: row.taskNumber,
          PositionName: this.data.positionNumber,
          Action: String(action), // 1 or 3
          AssignmentMode: 'TaskLevel',
          CountryId: this.commonService.getCurrentCountry(),
          LanId: this.loggeduser,
        };

        await firstValueFrom(
          this.http.post(
            this.baseUrl + 'api/TaskAssinment/SaveAssignment',
            params
          )
        );
      }
    }

    // Save selections before reloading data
    const savedSelections = this.saveTaskSelections();

    this.hasChanges = true;

    // Reload all data to refresh the UI and button states
    await this.loadCurrentAssignment();
    await this.loadTaskAssignmentData();
    await this.loadProximityData();
    
    // Restore selections after reloading data
    this.restoreTaskSelections(savedSelections);
    
    this.filterForm.patchValue({ firstName: '', lastName: '' });
    this.snackbar.openSnackBar('Assignment saved successfully.', 'success');
  } catch (error) {
    console.error('Error saving assignment:', error);
    this.snackbar.openSnackBar('Error while saving assignment. Please try again.', 'error');
  } finally {
    this.showSpinner = false;
    this.isSavingAssignment = false; // Reset guard flag
  }
}

  // ============================================================
  // AUTOCOMPLETE SEARCH
  // ============================================================
  private setupAutocomplete(): void {
    this.filteredFirstNames = this.filterForm
      .get('firstName')!
      .valueChanges.pipe(
        debounceTime(300),
        distinctUntilChanged((prev, curr) => {
          // Handle object-to-object comparison
          if (typeof prev === 'object' && typeof curr === 'object') {
            return prev?.id === curr?.id;
          }
          // Handle string-to-string comparison
          if (typeof prev === 'string' && typeof curr === 'string') {
            return prev === curr;
          }
          // Handle object-to-string or string-to-object transitions
          return false; // Always trigger on type change
        }),
        switchMap((value) => {
          // Clear selected ID if field is manually cleared
          if (!value || (typeof value === 'string' && value.trim().length === 0)) {
            this.selectedFirstNameId = '';
            return of([]);
          }
          
          // Only search if string length > 2
          if (typeof value === 'string' && value.length > 2) {
            return this.searchFirstNames(value);
          } else {
            return of([]);
          }
        }),
        takeUntil(this.destroy$)
      );

    this.filteredLastNames = this.filterForm
      .get('lastName')!
      .valueChanges.pipe(
        debounceTime(300),
        distinctUntilChanged((prev, curr) => {
          // Handle object-to-object comparison
          if (typeof prev === 'object' && typeof curr === 'object') {
            return prev?.id === curr?.id;
          }
          // Handle string-to-string comparison
          if (typeof prev === 'string' && typeof curr === 'string') {
            return prev === curr;
          }
          // Handle object-to-string or string-to-object transitions
          return false; // Always trigger on type change
        }),
        switchMap((value) => {
          // Clear selected ID if field is manually cleared
          if (!value || (typeof value === 'string' && value.trim().length === 0)) {
            this.selectedLastNameId = '';
            return of([]);
          }
          
          // Only search if string length > 2
          if (typeof value === 'string' && value.length > 2) {
            return this.searchLastNames(value);
          } else {
            return of([]);
          }
        }),
        takeUntil(this.destroy$)
      );
  }

private searchFirstNames(searchText: string): Observable<NameOption[]> {
    const params = {
      IriWeek: this.data.iriWeek,
      TerritoryId: this.filterForm.get('territory')?.value || this.data.territoryId,
      SearchText: searchText,
      NameType: 'first_name',
    };

    return this.http
      .post<any[]>(this.baseUrl + 'api/TaskAssinment/GetName', params)
      .pipe(
        map((response) =>
          response.map((item) => ({
            emp_name: item.emp_name,
            emp_id: item.emp_id,
            FirstName: item.FirstName,
            LastName: item.LastName,
            value: item.emp_name,
            id: item.emp_id,
          }))
        ),
        catchError((error) => {
          console.error('Error fetching first names:', error);
          return of([]);
        })
      );
  }

  private searchLastNames(searchText: string): Observable<NameOption[]> {
    const params = {
      IriWeek: this.data.iriWeek,
      TerritoryId: this.filterForm.get('territory')?.value || this.data.territoryId,
      SearchText: searchText,
      NameType: 'last_name',
    };

    return this.http
      .post<any[]>(this.baseUrl + 'api/TaskAssinment/GetName', params)
      .pipe(
        map((response) =>
          response.map((item) => ({
            emp_name: item.emp_name,
            emp_id: item.emp_id,
            FirstName: item.FirstName,
            LastName: item.LastName,
            value: item.emp_name,
            id: item.emp_id,
          }))
        ),
        catchError((error) => {
          console.error('Error fetching last names:', error);
          return of([]);
        })
      );
  }

  onFirstNameSelected(event: any): void {
    // MatAutocompleteSelectedEvent doesn't have stopPropagation, but optionSelected events
    // don't bubble to parent elements, so this is safe
    const selectedOption = event.option.value as NameOption;
    this.selectedFirstNameId = selectedOption.id;
    setTimeout(() => this.searchFsrs(), 100);
  }

  onLastNameSelected(event: any): void {
    // MatAutocompleteSelectedEvent doesn't have stopPropagation, but optionSelected events
    // don't bubble to parent elements, so this is safe
    const selectedOption = event.option.value as NameOption;
    this.selectedLastNameId = selectedOption.id;
    setTimeout(() => this.searchFsrs(), 100);
  }

  displayFn(option: NameOption): string {
    return option && option.FirstName ? option.FirstName : '';
  }

  onTerritoryChange(): void {
    this.filterForm.patchValue({
      firstName: '',
      lastName: '',
    });
    this.selectedFirstNameId = '';
    this.selectedLastNameId = '';
    this.fsrDataSource.data = [];
  }

  clearFirstNameCtrl(): void {
    this.filterForm.get('firstName')?.reset();
    this.selectedFirstNameId = '';
  }

  clearLastNameCtrl(): void {
    this.filterForm.get('lastName')?.reset();
    this.selectedLastNameId = '';
  }

  /**
   * Check if first name field has a value (string or object)
   * Used to show/hide clear button
   */
  hasFirstNameValue(): boolean {
    const value = this.filterForm.get('firstName')?.value;
    if (!value) return false;
    if (typeof value === 'string') {
      return value.trim().length > 0;
    }
    if (typeof value === 'object') {
      return !!(value.FirstName || value.value || value.id);
    }
    return false;
  }

  /**
   * Check if last name field has a value (string or object)
   * Used to show/hide clear button
   */
  hasLastNameValue(): boolean {
    const value = this.filterForm.get('lastName')?.value;
    if (!value) return false;
    if (typeof value === 'string') {
      return value.trim().length > 0;
    }
    if (typeof value === 'object') {
      return !!(value.LastName || value.FirstName || value.value || value.id);
    }
    return false;
  }

  /**
   * Check if at least one name field (firstName or lastName) has a value
   * Used to enable/disable search button
   */
  hasAtLeastOneNameField(): boolean {
    const firstNameValue = this.getFirstNameValue(this.filterForm.get('firstName')?.value);
    const lastNameValue = this.getLastNameValue(this.filterForm.get('lastName')?.value);
    return !!(firstNameValue || lastNameValue);
  }

  // ============================================================
  // DIALOG CLOSE
  // ============================================================
  async onClose(): Promise<void> {
    // Get current filters at close time to ensure all fields are preserved correctly
    let filtersToReturn = this.preservedFilters;
    
    try {
      const currentFilters = await firstValueFrom(this.commonService.currentFilters$);
      // Merge current filters with preserved filters to ensure all fields are present
      if (currentFilters && Object.keys(currentFilters).length > 0) {
        // Merge to preserve all fields, prioritizing preserved filters for critical fields
        filtersToReturn = {
          ...currentFilters,
          // Ensure critical fields from preserved filters or dialog data are maintained
          iri_week: this.preservedFilters?.iri_week || currentFilters.iri_week || this.data.iriWeek,
          territory_id: this.preservedFilters?.territory_id || currentFilters.territory_id || this.data.territoryId || this.filterForm.get('territory')?.value,
          country_id: this.preservedFilters?.country_id || currentFilters.country_id || this.commonService.getCurrentCountry() || '1',
        };
      } else if (!filtersToReturn || Object.keys(filtersToReturn).length === 0) {
        // If no current filters and no preserved filters, try to build from dialog data
        filtersToReturn = {
          iri_week: this.data.iriWeek,
          territory_id: this.data.territoryId || this.filterForm.get('territory')?.value,
          country_id: this.commonService.getCurrentCountry() || '1',
        };
      } else {
        // Ensure preserved filters have all required fields
        filtersToReturn = {
          ...filtersToReturn,
          iri_week: filtersToReturn.iri_week || this.data.iriWeek,
          territory_id: filtersToReturn.territory_id || this.data.territoryId || this.filterForm.get('territory')?.value,
          country_id: filtersToReturn.country_id || this.commonService.getCurrentCountry() || '1',
        };
      }
    } catch (error) {
      console.warn('Could not get current filters on close, using preserved filters:', error);
      // If preserved filters are not available, build from dialog data
      if (!filtersToReturn || Object.keys(filtersToReturn).length === 0) {
        filtersToReturn = {
          iri_week: this.data.iriWeek,
          territory_id: this.data.territoryId || this.filterForm.get('territory')?.value,
          country_id: this.commonService.getCurrentCountry() || '1',
        };
      } else {
        // Ensure preserved filters have all required fields
        filtersToReturn = {
          ...filtersToReturn,
          iri_week: filtersToReturn.iri_week || this.data.iriWeek,
          territory_id: filtersToReturn.territory_id || this.data.territoryId || this.filterForm.get('territory')?.value,
          country_id: filtersToReturn.country_id || this.commonService.getCurrentCountry() || '1',
        };
      }
    }
    
    const result: DialogResult = {
      hasChanges: this.hasChanges,
      preservedFilters: filtersToReturn,
    };
    this.dialogRef.close(result);
  }

  getDisplayedColumns2(): string[] {
    return this.displayedColumns;
  }

  private autoSelectBasedOnOrigin(): void {
  setTimeout(() => {
    if (this.originMode === 'StoreLevel') {
      // User came from main grid - auto-select "ALL"
      const allRow = this.taskAssignmentDataSource.data.find(r => r.isAllTask);
      if (allRow) {
        this.taskSelection.select(allRow);
      }
    } else if (this.originMode === 'TaskLevel' && this.data.taskNumber) {
      // User came from subgrid - auto-select that specific task
      const taskRow = this.taskAssignmentDataSource.data.find(
        r => r.taskNumber === this.data.taskNumber && !r.isAllTask
      );
      if (taskRow) {
        this.taskSelection.select(taskRow);
      }
    }
  }, 100);
}
  // ============================================================
  // HELPER METHOD: Unified Assign Logic
  // ============================================================
  private async assignTaskWithSelection(
    fsr: any,
    source: 'proximity' | 'fsr'
  ): Promise<void> {
    // Prevent concurrent calls
    if (this.isSavingAssignment) {
      return;
    }
    
    const selectedRows = this.taskSelection.selected;
    if (selectedRows.length === 0) {
      this.snackbar.openSnackBar('Please select at least one task to assign.', 'warning');
      return;
    }

    // Save selections before reloading data
    const savedSelections = this.saveTaskSelections();

    const fsrName =
      source === 'proximity'
        ? `${fsr.firstName} ${fsr.lastName}`
        : `${fsr.FirstName} ${fsr.LastName}`;
    const empId = source === 'proximity' ? fsr.empId : fsr.empid;

    const allSelected = selectedRows.some((row) => row.isAllTask);

    let confirmMessage: string;
    if (allSelected) {
      confirmMessage = `Are you sure you want to assign ${fsrName} to all tasks?`;
    } else {
      const taskNames = selectedRows.map((row) => row.taskName).join(', ');
      confirmMessage = `Are you sure you want to assign ${fsrName} to ${taskNames}?`;
    }

    // if (!confirm(confirmMessage)) {
    //   return;
    // }

    this.showSpinner = true;
    try {
      if (allSelected) {
        // Assign to ALL tasks
        const params = {
          IriWeek: this.data.iriWeek,
          TerritoryId: this.filterForm.get('territory')?.value,
          StoreNumber: this.data.storeNumber,
          EmpId: empId,
          TaskNumber: '',
          PositionNumber: this.data.positionNumber,
          Action: '2', // Assign all
          AssignmentMode: 'StoreLevel',
          CountryId: this.commonService.getCurrentCountry(),
          LanId: this.loggeduser,
        };

        await firstValueFrom(
          this.http.post(
            this.baseUrl + 'api/TaskAssinment/SaveAssignment',
            params
          )
        );
      } else {
        // Assign to SPECIFIC tasks
        for (const row of selectedRows) {
          const params = {
            IriWeek: this.data.iriWeek,
            TerritoryId: this.filterForm.get('territory')?.value,
            StoreNumber: row.storeNumber,
            EmpId: empId,
            TaskNumber: row.taskNumber,
            PositionNumber: this.data.positionNumber,
            Action: '1', // Assign specific task
            AssignmentMode: 'TaskLevel',
            CountryId: this.commonService.getCurrentCountry(),
            LanId: this.loggeduser,
          };

          await firstValueFrom(
            this.http.post(
              this.baseUrl + 'api/TaskAssinment/SaveAssignment',
              params
            )
          );
        }
      }

      this.hasChanges = true;

      await this.loadTaskAssignmentData();
      await this.loadProximityData();
      await this.loadCurrentAssignment(); // This will add current assignment rows to proximity table

      // Restore selections after reloading data
      this.restoreTaskSelections(savedSelections);
      
      this.filterForm.patchValue({ firstName: '', lastName: '' });
      this.snackbar.openSnackBar('Assignment saved successfully.', 'success');
    } catch (error) {
      console.error('Error saving assignment:', error);
      this.snackbar.openSnackBar('Error while saving assignment.', 'error');
    } finally {
      this.showSpinner = false;
      this.isSavingAssignment = false; // Reset guard flag
    }
  }

  /**
   * Check if an FSR is assigned to the currently selected task(s)
   * - If "ALL Task" is selected: Check if FSR is assigned to ANY task
   * - If specific task(s) are selected: Check if FSR is assigned to ANY of the selected tasks
   */

  isOptimalCollector(fsr: ProximityFsr): boolean {
    // Only show icon if proximityDataSource has data from GetClosestFsr API
    if (!this.proximityDataSource.data || this.proximityDataSource.data.length === 0) {
      return false;
    }

    // Find the first row from GetClosestFsr API (rowSource: 'proximity')
    // These are sorted by costRank, so the first one is the optimal collector
    const proximityRows = this.proximityDataSource.data.filter(
      (row: ProximityFsr) => row.rowSource === 'proximity'
    );
    
    // If no proximity rows exist, don't show icon
    if (proximityRows.length === 0) {
      return false;
    }

    // Get the first proximity row (optimal collector)
    const optimalCollector = proximityRows[0];
    
    // Check if this FSR matches the optimal collector by empId
    // Handle both lowercase and uppercase empId
    const fsrEmpId = String(fsr.empId || '').trim().toLowerCase();
    const optimalEmpId = String(optimalCollector.empId || '').trim().toLowerCase();
    
    return fsrEmpId === optimalEmpId && fsrEmpId !== '';
  }

  isAlreadyAssignedProximity(fsr: ProximityFsr): boolean {
    // Return false if task data not loaded yet
    if (
      !this.taskAssignmentDataSource.data ||
      this.taskAssignmentDataSource.data.length === 0
    ) {
      return false;
    }

    // Get selected tasks
    const selectedTasks = this.taskSelection.selected;
    if (selectedTasks.length === 0) {
      return false;
    }

    // Check if "ALL Task" is selected
    const allTaskSelected = selectedTasks.some(task => task.isAllTask);
    
    if (allTaskSelected) {
      // If ALL Task is selected, check if FSR is assigned to ANY task
      // Normalize FSR empId for comparison
      const fsrEmpId = String(fsr.empId || '').trim();
      if (!fsrEmpId) {
        return false;
      }

      return this.taskAssignmentDataSource.data.some((task) => {
        // Skip the "ALL" row and rows without assignment
        if (task.isAllTask || !task.assignedTo || task.assignedTo === 'Not Assigned') {
          return false;
        }

        // Method 1: Direct empId match (normalized)
        const taskEmpId = String(task.empId || '').trim();
        if (taskEmpId && taskEmpId === fsrEmpId) {
          return true;
        }

        // Method 2: Check if assignedTo contains FSR's empId
        if (task.assignedTo && typeof task.assignedTo === 'string') {
          const assignedToNormalized = task.assignedTo.trim();
          if (assignedToNormalized.includes(fsrEmpId)) {
            return true;
          }
        }

        return false;
      });
    } else {
      // Specific task(s) are selected - check if FSR is assigned to ANY of the selected tasks ONLY
      // Extract unique task numbers from selected rows
      const selectedTaskNumbers = selectedTasks
        .filter(task => !task.isAllTask && task.taskNumber)
        .map(task => String(task.taskNumber).trim()) // Normalize to string and trim
        .filter((taskNumber, index, self) => self.indexOf(taskNumber) === index); // Get unique task numbers

      if (selectedTaskNumbers.length === 0) {
        return false;
      }

      // Normalize FSR empId for comparison
      const fsrEmpId = String(fsr.empId || '').trim();
      if (!fsrEmpId) {
        return false;
      }

      // Check if FSR is assigned to any of the SELECTED tasks only
      // This is critical: we only check tasks that match the selected task numbers
      return this.taskAssignmentDataSource.data.some((task) => {
        // Skip the "ALL" row and rows without assignment
        if (task.isAllTask || !task.assignedTo || task.assignedTo === 'Not Assigned') {
          return false;
        }

        // Normalize task number for comparison
        const taskNumber = String(task.taskNumber || '').trim();
        
        // CRITICAL: Only check tasks that match the selected task numbers
        // If taskNumber doesn't match any selected task, skip it
        if (!taskNumber || !selectedTaskNumbers.includes(taskNumber)) {
          return false;
        }

        // At this point, we know this task row matches one of the selected task numbers
        // Now check if this FSR is assigned to this specific task

        // Method 1: Direct empId match (normalized)
        const taskEmpId = String(task.empId || '').trim();
        if (taskEmpId && taskEmpId === fsrEmpId) {
          return true; // FSR is assigned to this selected task
        }

        // Method 2: Check if assignedTo contains FSR's empId
        if (task.assignedTo && typeof task.assignedTo === 'string') {
          const assignedToNormalized = task.assignedTo.trim();
          if (assignedToNormalized.includes(fsrEmpId)) {
            return true; // FSR is assigned to this selected task
          }
        }

        return false; // FSR is not assigned to this specific task
      });
    }
  }

isAllTaskSelected(): boolean {
  const allRow = this.taskAssignmentDataSource.data.find((r) => r.isAllTask);
  
  if (!allRow) {
    return false;
  }
  
  return this.taskSelection.isSelected(allRow);
}
getSpecificTasksSelectedCount(): number {
  return this.taskSelection.selected.filter((row) => !row.isAllTask).length;
}

isAnySpecificTaskSelected(): boolean {
  return this.getSpecificTasksSelectedCount() > 0;
}

}
***********************************************
    <h2 mat-dialog-title class="title-style" cdkDrag cdkDragRootElement=".cdk-overlay-pane" cdkDragHandle>
  <span cdkDragHandle>{{ getDialogTitle() }}</span>
    <button 
  mat-icon-button
  aria-label="close dialog"
  class="header-close-btn"
  (click)="onClose(); $event.stopPropagation()"
  >
    <mat-icon style="vertical-align: sub;">close</mat-icon>
  </button>
</h2>

<mat-dialog-content class="assignment-dialog-content">

  <!-- ============================================================ -->
  <!-- FILTER SECTION - AT TOP -->
  <!-- ============================================================ -->
  <div class="filter-section-container" [formGroup]="filterForm">
    <div class="filter-row">
      <mat-form-field appearance="outline" class="small-field">
        <mat-label>IRI Week</mat-label>
        <input matInput [value]="data.iriWeek" readonly />
      </mat-form-field>

      <mat-form-field appearance="outline" class="medium-field">
        <mat-label>Territory</mat-label>
        <mat-select formControlName="territory" (selectionChange)="onTerritoryChange()">
          <mat-option *ngFor="let territory of territories" [value]="territory.territory_id">
            {{ territory.territory_name }}
          </mat-option>
        </mat-select>
      </mat-form-field>

      <mat-form-field appearance="outline" class="medium-field">
        <mat-label>First Name</mat-label>
        <input
          matInput
          formControlName="firstName"
          placeholder="Search by first name..."
          [matAutocomplete]="firstNameAuto"
        />
        <button mat-button *ngIf="hasFirstNameValue()" matSuffix mat-icon-button (click)="clearFirstNameCtrl(); $event.stopPropagation()">
          <mat-icon>cancel</mat-icon>
        </button>
        <mat-autocomplete
          #firstNameAuto="matAutocomplete"
          (optionSelected)="onFirstNameSelected($event)"
          [displayWith]="displayFn"
        >
          <mat-option *ngFor="let option of filteredFirstNames | async" [value]="option">
            {{ option.FirstName }} {{ option.LastName }}
          </mat-option>
        </mat-autocomplete>
      </mat-form-field>

      <mat-form-field appearance="outline" class="medium-field">
        <mat-label>Last Name</mat-label>
        <input
          matInput
          formControlName="lastName"
          placeholder="Search by last name..."
          [matAutocomplete]="lastNameAuto"
        />
        <button mat-button *ngIf="hasLastNameValue()" matSuffix mat-icon-button (click)="clearLastNameCtrl(); $event.stopPropagation()">
          <mat-icon>cancel</mat-icon>
        </button>
        <mat-autocomplete
          #lastNameAuto="matAutocomplete"
          (optionSelected)="onLastNameSelected($event)"
          [displayWith]="displayFn"
        >
          <mat-option *ngFor="let option of filteredLastNames | async" [value]="option">
            {{ option.FirstName }} {{ option.LastName }}
          </mat-option>
        </mat-autocomplete>
      </mat-form-field>

      <button
        mat-raised-button
        color="primary"
        (click)="searchFsrs(); $event.stopPropagation()"
        [disabled]="isLoading || !hasAtLeastOneNameField()"
        class="search-btn"
      >
        <mat-icon>search</mat-icon>
        Search
      </button>
    </div>
  </div>

  <!-- ============================================================ -->
  <!-- ACCORDION CONTAINER FOR ALL TABLES -->
  <!-- ============================================================ -->
  <mat-accordion class="tables-accordion" multi>

 

    <!-- ============================================================ -->
    <!-- TABLE 1: Task Assignment Selection Table -->
    <!-- ============================================================ -->
    <mat-expansion-panel class="accordion-panel" [expanded]="true">
      <mat-expansion-panel-header class="accordion-header">
        <mat-panel-title>
          <mat-icon>assignment</mat-icon>
          Select Task/Store to Assign
        </mat-panel-title>
      </mat-expansion-panel-header>

      <div class="table-section task-assignment-section">
        <div *ngIf="isLoadingTaskAssignment" class="loading-container">
          <mat-spinner diameter="30"></mat-spinner>
          <span>Loading task data...</span>
        </div>

        <div class="table-wrapper" *ngIf="!isLoadingTaskAssignment">
          <table mat-table [dataSource]="taskAssignmentDataSource" class="task-assignment-table mat-elevation-z2">

            <!-- Checkbox Column -->
            <ng-container matColumnDef="select">
              <th mat-header-cell *matHeaderCellDef class="col-checkbox">Action</th>
              <td mat-cell *matCellDef="let row" class="col-checkbox">
                <mat-checkbox
                  (click)="$event.stopPropagation()"
                  (change)="onCheckboxChange($event, row)"
                  [checked]="taskSelection.isSelected(row)"
                  [disabled]="isCheckboxDisabled(row)"
                >
                </mat-checkbox>
              </td>
            </ng-container>

            <!-- Position Column -->
            <ng-container matColumnDef="position">
              <th mat-header-cell *matHeaderCellDef class="col-position">Position</th>
              <td mat-cell *matCellDef="let row">{{ row.positionName || row.PositionName || 'N/A' }}</td>
            </ng-container>

            <!-- Store Number Column -->
            <ng-container matColumnDef="storeNumber">
              <th mat-header-cell *matHeaderCellDef class="col-store-number">Store #</th>
              <td mat-cell *matCellDef="let row">{{ row.storeNumber }}</td>
            </ng-container>

            <!-- Store Name Column -->
            <ng-container matColumnDef="storeName">
              <th mat-header-cell *matHeaderCellDef class="col-store-name">Store Name</th>
              <td mat-cell *matCellDef="let row" [matTooltip]="row.storeName" matTooltipPosition="above">
                {{ row.storeName }}
              </td>
            </ng-container>

            <!-- Address Column -->
            <ng-container matColumnDef="address">
              <th mat-header-cell *matHeaderCellDef class="col-address">Address</th>
              <td mat-cell *matCellDef="let row" [matTooltip]="row.address" matTooltipPosition="above">
                {{ row.address }}
              </td>
            </ng-container>

            <!-- City Column -->
            <ng-container matColumnDef="city">
              <th mat-header-cell *matHeaderCellDef class="col-city">City</th>
              <td mat-cell *matCellDef="let row">{{ row.city }}</td>
            </ng-container>

            <!-- Assigned To Column -->
            <ng-container matColumnDef="assignedTo">
              <th mat-header-cell *matHeaderCellDef class="col-assigned-to">Assigned To</th>
              <td mat-cell *matCellDef="let row">{{ row.assignedTo || 'Not Assigned' }}</td>
            </ng-container>

            <!-- Task Column -->
            <ng-container matColumnDef="task">
              <th mat-header-cell *matHeaderCellDef class="col-task">Task</th>
              <td mat-cell *matCellDef="let row" [ngClass]="{ 'all-task-cell': row.isAllTask }" class="col-task-cell">
                <strong *ngIf="row.isAllTask">{{ row.taskName }}</strong>
                <span *ngIf="!row.isAllTask">{{ row.taskName }}</span>
              </td>
            </ng-container>

            <tr mat-header-row *matHeaderRowDef="taskAssignmentColumns; sticky: true"></tr>
            <tr
              mat-row
              *matRowDef="let row; columns: taskAssignmentColumns"
              [ngClass]="{ 'all-task-row': row.isAllTask }"
              (click)="onRowClick($event, row)"
            >
            </tr>
          </table>

          <div *ngIf="taskAssignmentDataSource.data.length === 0" class="no-data">
            No tasks available for assignment.
          </div>
        </div>

        <!-- <div class="selection-info" *ngIf="taskSelection.selected.length > 0">
          <mat-icon>info</mat-icon>
          <span>{{ taskSelection.selected.length }} task(s) selected</span>
        </div> -->
      </div>
    </mat-expansion-panel>

    <!-- ============================================================ -->
<!-- TABLE 2: Proximity FSR Table (Closest FSRs) -->
<!-- ============================================================ -->
<mat-expansion-panel class="accordion-panel" [expanded]="true">
  <mat-expansion-panel-header class="accordion-header">
    <mat-panel-title>
      <mat-icon>location_on</mat-icon>
      Closest FSRs
    </mat-panel-title>
  </mat-expansion-panel-header>

  <div class="table-section proximity-section">
    <div *ngIf="isLoadingProximity || isLoading" class="loading-container">
      <mat-spinner diameter="30"></mat-spinner>
      <span *ngIf="isLoadingProximity">Loading proximity data...</span>
      <span *ngIf="!isLoadingProximity && isLoading">Searching FSRs...</span>
    </div>

    <div class="table-wrapper" *ngIf="!isLoadingProximity && !isLoading && proximityDataSource.data.length > 0">
      <table mat-table [dataSource]="proximityDataSource" class="proximity-table mat-elevation-z2">

        <!-- ACTION COLUMN - SINGLE BUTTON (Assign or Unassign) -->
        <ng-container matColumnDef="action">
          <th mat-header-cell *matHeaderCellDef class="col-action">Action</th>
          <td mat-cell *matCellDef="let fsr">
            <!-- CASE 1: ALL ROW SELECTED IN TABLE 3 -->
            <!-- Show Assign All or Unassign All based on FSR assignment status -->
            <ng-container *ngIf="isAllTaskSelected()">
              <!-- Show ASSIGN ALL button if FSR is NOT assigned -->
              <button
                *ngIf="!isAlreadyAssignedProximity(fsr)"
                mat-stroked-button
                color="primary"
                (click)="assignFromProximity(fsr); $event.stopPropagation()"
                [disabled]="taskSelection.selected.length === 0 || showSpinner"
                class="action-button no-border"
              >
                <!-- <mat-icon>person_add</mat-icon> -->
                Assign All
              </button>

              <!-- Show UNASSIGN ALL button if FSR IS assigned -->
              <button
                *ngIf="isAlreadyAssignedProximity(fsr)"
                mat-stroked-button
                color="warn"
                (click)="unassignFromProximity(fsr); $event.stopPropagation()"
                [disabled]="taskSelection.selected.length === 0 || showSpinner"
                class="action-button no-border"
              >
                <!-- <mat-icon>person_remove</mat-icon> -->
                Unassign All
              </button>
            </ng-container>

            <!-- CASE 2: SPECIFIC TASK(S) SELECTED IN TABLE 3 -->
            <!-- Show Assign or Unassign based on FSR assignment status -->
            <ng-container *ngIf="!isAllTaskSelected() && taskSelection.selected.length > 0">
              <!-- Show ASSIGN button if FSR is NOT assigned -->
              <button
                *ngIf="!isAlreadyAssignedProximity(fsr)"
                mat-stroked-button
                color="primary"
                (click)="assignFromProximity(fsr); $event.stopPropagation()"
                [disabled]="taskSelection.selected.length === 0 || showSpinner"
                class="action-button no-border"
              >
                <!-- <mat-icon>person_add</mat-icon> -->
                Assign
              </button>

              <!-- Show UNASSIGN button if FSR IS assigned -->
              <button
                *ngIf="isAlreadyAssignedProximity(fsr)"
                mat-stroked-button
                color="warn"
                (click)="unassignFromProximity(fsr); $event.stopPropagation()"
                [disabled]="taskSelection.selected.length === 0 || showSpinner"
                class="action-button no-border"
              >
                <!-- <mat-icon>person_remove</mat-icon> -->
                Unassign
              </button>
            </ng-container>

            <!-- CASE 3: NO TASKS SELECTED -->
            <ng-container *ngIf="!isAllTaskSelected() && taskSelection.selected.length <= 0">
              <!-- Show ASSIGN button if FSR is NOT assigned -->
              <button
                *ngIf="!isAlreadyAssignedProximity(fsr)"
                mat-stroked-button
                color="primary"
                [disabled]="taskSelection.selected.length === 0 || showSpinner"
                class="action-button no-border"
              >
                <!-- <mat-icon>person_add</mat-icon> -->
                Assign
              </button>

              <!-- Show UNASSIGN button if FSR IS assigned -->
              <button
                *ngIf="isAlreadyAssignedProximity(fsr)"
                mat-stroked-button
                color="warn"
                [disabled]="taskSelection.selected.length === 0 || showSpinner"
                class="action-button no-border"
              >
                <!-- <mat-icon>person_remove</mat-icon> -->
                Unassign
              </button>
            </ng-container>
          </td>
        </ng-container>

        <!-- Employee ID Column -->
        <ng-container matColumnDef="empId">
          <th mat-header-cell *matHeaderCellDef class="col-emp-id">Employee ID</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.empId }}</td>
        </ng-container>

        <!-- Employee Name Column -->
        <ng-container matColumnDef="empName">
          <th mat-header-cell *matHeaderCellDef class="col-emp-name">Name</th>
          <td mat-cell *matCellDef="let fsr">
            <mat-icon *ngIf="isOptimalCollector(fsr)" 
            style="vertical-align: bottom; color: royalblue;" 
            matTooltip="Optimal Collector">stars</mat-icon>
            {{ fsr.firstName }} {{ fsr.lastName }}
      
          </td>
        </ng-container>

        <!-- Productivity Column -->
        <ng-container matColumnDef="productivity">
          <th mat-header-cell *matHeaderCellDef class="col-productivity">Productivity</th>
          <td mat-cell *matCellDef="let fsr">{{ (fsr.productivity != null && fsr.productivity !== '') ? fsr.productivity + '%' : '' }}</td>
        </ng-container>

        <!-- Cost Column -->
        <ng-container matColumnDef="cost">
          <th mat-header-cell *matHeaderCellDef class="col-cost">Travel Cost</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.totalCost }}</td>
        </ng-container>

        <!-- Travel Time Column -->
        <ng-container matColumnDef="time">
          <th mat-header-cell *matHeaderCellDef class="col-time">Travel Time</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.time }}</td>
        </ng-container>

        <!-- Toll Column -->
        <ng-container matColumnDef="toll">
          <th mat-header-cell *matHeaderCellDef class="col-toll">Toll</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.toll }}</td>
        </ng-container>

        <!-- Phone Column -->
        <ng-container matColumnDef="phone">
          <th mat-header-cell *matHeaderCellDef class="col-phone">Phone</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.fsrPhoneNum }}</td>
        </ng-container>

        <!-- Email Column -->
        <ng-container matColumnDef="email">
          <th mat-header-cell *matHeaderCellDef class="col-email">Email</th>
          <td mat-cell *matCellDef="let fsr">
            <a href="mailto:{{ fsr.email }}" class="email-link">{{ fsr.email }}</a>
          </td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="proximityColumns; sticky: true"></tr>
        <tr mat-row *matRowDef="let row; columns: proximityColumns"></tr>
      </table>
    </div>

    <div *ngIf="!isLoadingProximity && !isLoading && proximityDataSource.data.length === 0" class="no-data">
      No FSRs available. Please try searching.
    </div>
  </div>
</mat-expansion-panel>

  </mat-accordion>

</mat-dialog-content>

<!-- <mat-dialog-actions align="end" class="dialog-actions">
  <button mat-button (click)="onClose()">
    <mat-icon>close</mat-icon>
    Close
  </button>
</mat-dialog-actions> -->

<footer>
  <div class="mat-spinner-container">
    <mat-spinner mode="indeterminate" *ngIf="showSpinner"></mat-spinner>
    <div *ngIf="showSpinner" style="position: relative; left: 10px">Loading...</div>
  </div>
</footer>
